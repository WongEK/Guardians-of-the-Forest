//startup variables
var canvas = document.getElementById("game");
var ctx = canvas.getContext("2d");

var userScore = 10;
//can be used to hold score 
var dialogue = document.getElementById("dialogue");
dialogue.innerHTML = "Score: " + userScore;


//grass background image
function grass() {
//background image variable and load
var grassBackground = new Image();
grassBackground.src = "../assets/sprites/grassField1.png";

	grassBackground.onload = function() {
		ctx.drawImage(grassBackground, 0, 0);
	}
}

grass();

/** OLD TREE CREATION, OVERLAPS TREES *******
function tree() {
	var tree = new Image();
	tree.src = "../assets/sprites/tree.png";
	tree.onload = function() {
	for(let i = 0; i < 20; i++) {
			var randX = Math.floor(Math.random() * 750);
			var randY = Math.floor(Math.random() * 550);
			ctx.drawImage(tree, randX, randY);
	}
	}
}

tree();

*/

//holds array for tree positions
var treeArray = [],
    arrSize = 100,
    arrWidth = 800,
    arrHeight = 600;

/**********SECOND TREE GENERATION*********8
//generates random positions for tree array
function generateTreeArray(k) {
  var placed = 0,
      maxAttempts = k*10;
  while(placed < k && maxAttempts > 0) {
    var x = Math.floor(Math.random()* arrWidth),
        y = Math.floor(Math.random()* arrHeight),
        available = true;
    for(var point in treeArray) {
      if(Math.abs(point.x-x) < arrSize && Math.abs(point.y-y) < arrSize) {
        available = false;
        break;
      }
    }
    if(available) {
      treeArray.push({
        x: x,
        y: y
      });
      placed += 1;
    }
    maxAttempts -= 1;
  }
}

generateTreeArray(100);
console.log(treeArray);

function placeTrees() {
	var tree = new Image();
	tree.src = "../assets/sprites/tree.png";
	tree.onload = function() {
		for(let i = 0; i < treeArray.length; i++){
			ctx.drawImage(tree, treeArray[i].x, treeArray[i].y);	
		}
	}
}

placeTrees();

*/


function setup() {
	
  var circles = [],
      circle = {},
      overlapping = false,
      NumCircles = 200,
      protection = 10000,
      counter = 0;

  // populate circles array
  // brute force method continues until # of circles target is reached
  // or until the protection value is reached
  while (circles.length < NumCircles && counter < protection) {
    circle = {
      x: random(width),
      y: random(height),
      r: random(3, 36)
    };
    overlapping = false;
    
    // check that it is not overlapping with any existing circle
    // another brute force approach
    for (var i = 0; i < circles.length; i++) {
      var existing = circles[i];
      var d = dist(circle.x, circle.y, existing.x, existing.y)
      if (d < circle.r + existing.r) {
        // They are overlapping
        overlapping = true;
        // do not add to array
        break;
      }
    }
    
    // add valid circles to array
    if (!overlapping) {
      circles.push(circle);      
    }
    
    counter++;
  }
  
  for (var i = 0; i < circles.length; i++) {
    ellipse(circles[i].x, circles[i].y, 
            circles[i].r*2, circles[i].r*2);
  }
}

setup();

